{"version":3,"sources":["../../src/worker.ts","../../src/worker/utils.ts","../../src/worker/state.ts","../../src/shared/utils.ts","../../src/worker/csrf.ts","../../src/worker/interceptor.ts","../../node_modules/jwt-decode/lib/atob.js","../../node_modules/jwt-decode/lib/base64_url_decode.js","../../node_modules/jwt-decode/lib/index.js","../../src/worker/operations.ts","../../src/worker/postMesage.ts","../../src/worker/index.ts","../../src/providers.ts","../../src/shared/presets.ts","../sw/service-worker.ts"],"sourcesContent":["export * from './worker/index';\n","import { getState } from './state';\n\nexport function getHashParams(): Record<string, string> {\n\tconst fragmentString = location.hash.substring(1);\n\n\t// Parse query string to see if page request is coming from OAuth 2.0 server.\n\tconst params: Record<string, string> = {};\n\tconst regex = /([^&=]+)=([^&]*)/g;\n\tlet m;\n\twhile ((m = regex.exec(fragmentString))) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tconst [_, name, value] = m;\n\t\tparams[name] = decodeURIComponent(value);\n\t}\n\n\treturn params;\n}\n\nexport function log(...args: Array<unknown>): void {\n\tgetState().then(\n\t\t(state) => {\n\t\t\tif (state.config?.debug) {\n\t\t\t\tconsole.log('[auth-worker]', ...args);\n\t\t\t}\n\t\t},\n\t\t() => null\n\t);\n}\n","import { IBaseConfig } from '../interfaces/IBaseConfig';\nimport { IFullConfig } from '../interfaces/IFullConfig';\nimport { IProvider } from '../interfaces/IProvider';\nimport { log } from './utils';\n\ninterface IState {\n\tcsrf?: string;\n\tconfig?: IFullConfig;\n\tsession?: {\n\t\tprovider: keyof IState['providers'];\n\t\taccessToken: string;\n\t\texpiresAt: number;\n\t\trefreshToken?: string;\n\t\ttokenType: string;\n\t\tuserInfo?: string;\n\t};\n\tproviders: Record<string, IProvider>;\n}\n\nlet state: IState | null = null;\n\nexport async function getState() {\n\tif (!state) {\n\t\tconst match = await caches.match('state');\n\t\tstate = match ? ((await match.json()) as IState) : { providers: {} };\n\t\tlog('getState', state);\n\t}\n\treturn state;\n}\n\nexport async function saveState() {\n\tconst cache = await caches.open('v1');\n\tlog('saveState', state);\n\tawait cache.put('state', new Response(JSON.stringify(state)));\n}\n\nexport const getProviderParams = async (): Promise<IProvider> => {\n\tconst state = await getState();\n\tif (!state.session?.provider) {\n\t\tthrow new Error('No provider found');\n\t}\n\tconst providerParams = state.config?.providers?.[state.session?.provider];\n\tif (!providerParams) {\n\t\tthrow new Error('No provider params found');\n\t}\n\treturn providerParams;\n};\n\nexport const getProviderOptions = async (): Promise<IBaseConfig> => {\n\tconst state = await getState();\n\tif (!state.session?.provider) {\n\t\tthrow new Error('No provider found');\n\t}\n\tconst providerOptions = state.config?.config?.[state.session?.provider];\n\tif (!providerOptions) {\n\t\tthrow new Error('No provider options found');\n\t}\n\treturn providerOptions;\n};\n","export function getRandom() {\n\tif ('crypto' in globalThis && 'randomUUID' in globalThis.crypto) {\n\t\treturn globalThis.crypto.randomUUID();\n\t}\n\treturn Math.random().toString(36).slice(2);\n}\n","import { getState, saveState } from './state';\nimport { getRandom } from '../shared/utils';\n\nexport async function getCsrfToken() {\n\tconst state = await getState();\n\tif (state.csrf === null) {\n\t\tstate.csrf = getRandom();\n\t\tsaveState();\n\t}\n\treturn state.csrf;\n}\n\nexport async function checkCsrfToken(token: string) {\n\tconst state = await getState();\n\treturn state.csrf === token;\n}\n","import { AuthError } from '../shared/enums';\nimport { checkCsrfToken } from './csrf';\nimport { getProviderOptions, getProviderParams, getState, saveState } from './state';\nimport { log } from './utils';\n\nfunction generateResponse(resp: null | Record<string, unknown>, status = 200): Response {\n\treturn new Response(JSON.stringify(resp), {\n\t\theaders: { 'Content-Type': 'application/json' },\n\t\tstatus,\n\t});\n}\n\nexport async function refreshToken(): Promise<void> {\n\tconst state = await getState();\n\tconst providerParams = await getProviderParams();\n\tconst providerOptions = await getProviderOptions();\n\tif (!providerParams || !providerParams?.tokenUrl || !state.session?.refreshToken) {\n\t\tthrow new Error('No way to refresh the token');\n\t}\n\n\tconst resp = await fetch(providerParams.tokenUrl, {\n\t\tmethod: 'POST',\n\t\theaders: {\n\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t},\n\t\tbody: new URLSearchParams({\n\t\t\tclient_id: providerOptions.clientId,\n\t\t\tgrant_type: 'refreshToken',\n\t\t\trefreshToken: state.session.refreshToken,\n\t\t}),\n\t});\n\n\tif (resp.status !== 200) {\n\t\tthrow new Error('Could not refresh token');\n\t}\n\n\tconst response = await resp.json();\n\n\tstate.session = {\n\t\tprovider: state.session.provider,\n\t\taccessToken: response.access_token,\n\t\ttokenType: response.token_type,\n\t\trefreshToken: response.refresh_token,\n\t\texpiresAt: Date.now() + response.expires_in * 1000,\n\t};\n\n\tif (providerParams.userInfoTokenName) {\n\t\tstate.session.userInfo = response[providerParams.userInfoTokenName];\n\t}\n\tsaveState();\n}\n\nexport async function fetchWithCredentials(request: Request): Promise<Response> {\n\tconst state = await getState();\n\tif (!state.session) {\n\t\treturn generateResponse({ error: AuthError.Unauthorized }, 401);\n\t} else if (state.session.expiresAt < Date.now()) {\n\t\ttry {\n\t\t\tawait refreshToken();\n\t\t} catch {\n\t\t\treturn generateResponse({ error: AuthError.Unauthorized }, 401);\n\t\t}\n\t}\n\n\tconst updatedRequest = new Request(request, {\n\t\theaders: {\n\t\t\t...request.headers,\n\t\t\tAuthorization: `${state.session.tokenType} ${state.session.accessToken}`,\n\t\t\t'X-CSRF-Token': undefined,\n\t\t\t'X-Use-Auth': undefined,\n\t\t},\n\t});\n\tconst response = await fetch(updatedRequest);\n\tif (response.status === 401) {\n\t\ttry {\n\t\t\tawait refreshToken();\n\t\t} catch {\n\t\t\treturn generateResponse({ error: AuthError.Unauthorized }, 401);\n\t\t}\n\t}\n\treturn response;\n}\n\nexport async function fetchListener(event: FetchEvent) {\n\tif (event.request.method !== 'GET') {\n\t\tconst csrf = event.request.headers.get('X-CSRF-Token');\n\t\tif (!csrf || !(await checkCsrfToken(csrf))) {\n\t\t\treturn event.respondWith(generateResponse({ error: AuthError.InvalidCSRF }, 400));\n\t\t}\n\t}\n\n\tif (event.request.headers.get('X-Use-Auth')) {\n\t\tlog('fetch', event.request.method, event.request.url, {\n\t\t\tcsrf: Boolean(event.request.headers.get('X-CSRF-Token')),\n\t\t\tauth: Boolean(event.request.headers.get('X-Use-Auth')),\n\t\t});\n\t\treturn event.respondWith(fetchWithCredentials(event.request));\n\t}\n}\n","/**\n * The code was extracted from:\n * https://github.com/davidchambers/Base64.js\n */\n\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\nfunction InvalidCharacterError(message) {\n    this.message = message;\n}\n\nInvalidCharacterError.prototype = new Error();\nInvalidCharacterError.prototype.name = \"InvalidCharacterError\";\n\nfunction polyfill(input) {\n    var str = String(input).replace(/=+$/, \"\");\n    if (str.length % 4 == 1) {\n        throw new InvalidCharacterError(\n            \"'atob' failed: The string to be decoded is not correctly encoded.\"\n        );\n    }\n    for (\n        // initialize result and counters\n        var bc = 0, bs, buffer, idx = 0, output = \"\";\n        // get next character\n        (buffer = str.charAt(idx++));\n        // character found in table? initialize bit storage and add its ascii value;\n        ~buffer &&\n        ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n            // and if not first of each 4 characters,\n            // convert the first 8 bits to one ascii character\n            bc++ % 4) ?\n        (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6)))) :\n        0\n    ) {\n        // try to find character in table (0-63, not found => -1)\n        buffer = chars.indexOf(buffer);\n    }\n    return output;\n}\n\nexport default (typeof window !== \"undefined\" &&\n    window.atob &&\n    window.atob.bind(window)) ||\npolyfill;","import atob from \"./atob\";\n\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(\n        atob(str).replace(/(.)/g, function(m, p) {\n            var code = p.charCodeAt(0).toString(16).toUpperCase();\n            if (code.length < 2) {\n                code = \"0\" + code;\n            }\n            return \"%\" + code;\n        })\n    );\n}\n\nexport default function(str) {\n    var output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw \"Illegal base64url string!\";\n    }\n\n    try {\n        return b64DecodeUnicode(output);\n    } catch (err) {\n        return atob(output);\n    }\n}","\"use strict\";\n\nimport base64_url_decode from \"./base64_url_decode\";\n\nexport function InvalidTokenError(message) {\n    this.message = message;\n}\n\nInvalidTokenError.prototype = new Error();\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\n\nexport default function(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified\");\n    }\n\n    options = options || {};\n    var pos = options.header === true ? 0 : 1;\n    try {\n        return JSON.parse(base64_url_decode(token.split(\".\")[pos]));\n    } catch (e) {\n        throw new InvalidTokenError(\"Invalid token specified: \" + e.message);\n    }\n}","import jwtDecode from 'jwt-decode';\nimport { GrantFlow } from '../shared/enums';\nimport { getState, saveState } from './state';\nimport { log } from './utils';\n\nexport async function createSession(params: string, provider: string, localState: string) {\n\tconst state = await getState();\n\tconst parsedParams = new URLSearchParams(params);\n\n\tif (!state.config) {\n\t\tthrow new Error('No config found');\n\t}\n\n\tconst providerParams = state.config.providers?.[provider];\n\tconst providerOptions = state.config.config?.[provider];\n\n\tif (!providerParams) {\n\t\tthrow new Error('No provider params found');\n\t}\n\n\tconst stateParam = parsedParams.get(providerParams.stateParam ?? 'state');\n\tif (stateParam !== localState) {\n\t\tthrow new Error('Invalid state');\n\t}\n\n\tif (providerParams.grantType === GrantFlow.Token) {\n\t\tconst expiresIn = parseInt(parsedParams.get(providerParams.expiresInName ?? 'expires_in') ?? '', 10) || 3600;\n\t\tconst accessToken = parsedParams.get(providerParams.accessTokenName ?? 'access_token');\n\t\tif (!accessToken) {\n\t\t\tthrow new Error('No access token found');\n\t\t}\n\t\tstate.session = {\n\t\t\tprovider,\n\t\t\taccessToken,\n\t\t\tuserInfo: providerParams.userInfoTokenName\n\t\t\t\t? parsedParams.get(providerParams.userInfoTokenName) ?? undefined\n\t\t\t\t: undefined,\n\t\t\ttokenType: parsedParams.get(providerParams.tokenTypeName ?? 'token_type') ?? 'Bearer',\n\t\t\texpiresAt: Date.now() + expiresIn * 1000,\n\t\t};\n\t\tlog('state', state);\n\t}\n\n\tif (providerParams.grantType === GrantFlow.AuthorizationCode) {\n\t\tconst accessCode = parsedParams.get(providerParams.authorizationCodeParam ?? 'code');\n\t\tif (!accessCode) {\n\t\t\tthrow new Error('No access code found');\n\t\t}\n\t\tconst res = await fetch(providerParams.tokenUrl, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t\t},\n\t\t\tbody: new URLSearchParams({\n\t\t\t\tclient_id: providerOptions.clientId,\n\t\t\t\tgrant_type: 'authorization_code',\n\t\t\t\tcode: accessCode,\n\t\t\t}),\n\t\t});\n\n\t\tif (res.status !== 200) {\n\t\t\tthrow new Error('Could not get token');\n\t\t}\n\n\t\tconst response = await res.json();\n\n\t\tconst expiresIn = response[providerParams.expiresInName ?? ''] || 3600;\n\t\tconst accessToken = response[providerParams.accessTokenName ?? 'access_token'];\n\n\t\tif (!accessToken) {\n\t\t\tthrow new Error('No access token found');\n\t\t}\n\n\t\tstate.session = {\n\t\t\tprovider,\n\t\t\taccessToken,\n\t\t\ttokenType: response[providerParams.tokenTypeName ?? 'token_type'] ?? 'Bearer',\n\t\t\trefreshToken: response[providerParams.refreshTokenName ?? ''],\n\t\t\tuserInfo: response[providerParams.userInfoTokenName ?? ''],\n\t\t\texpiresAt: Date.now() + expiresIn * 1000,\n\t\t};\n\t\tlog('state', state);\n\t}\n\n\tsaveState();\n\treturn getUserData();\n}\n\nexport async function getUserData() {\n\tconst state = await getState();\n\tif (!state.session) {\n\t\tlog('state', state);\n\t\tthrow new Error('No session found');\n\t}\n\n\tconst providerParams = state.config?.providers?.[state.session.provider];\n\tif (state.session.userInfo) {\n\t\tconst decoded: Record<string, unknown> = jwtDecode(state.session.userInfo);\n\t\treturn providerParams?.userInfoParser?.(decoded) || decoded;\n\t} else if (providerParams?.userInfoUrl) {\n\t\tconst resp = await fetch(providerParams.userInfoUrl, {\n\t\t\theaders: {\n\t\t\t\tAuthorization: `${state.session.tokenType} ${state.session.accessToken}`,\n\t\t\t},\n\t\t});\n\t\tif (resp.status !== 200) {\n\t\t\tthrow new Error('Could not get user info');\n\t\t}\n\t\tconst response = await resp.json();\n\t\treturn providerParams?.userInfoParser?.(response) || response;\n\t}\n\n\tthrow new Error('No way to get user info');\n}\n\nexport async function deleteSession() {\n\tconst state = await getState();\n\tstate.session = undefined;\n\tsaveState();\n}\n","import { getCsrfToken } from './csrf';\nimport { createSession, getUserData, deleteSession } from './operations';\nimport { log } from './utils';\n\nconst operations = {\n\tgetCsrfToken,\n\tcreateSession,\n\tgetUserData,\n\tdeleteSession,\n} as const;\n\nexport async function messageListener(event: ExtendableMessageEvent) {\n\tlog('message', event.data.type, event.data.fnName);\n\tif (event.data.type === 'call') {\n\t\tif (event.data.fnName in operations) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst fn = operations[event.data.fnName as keyof typeof operations] as any;\n\t\t\ttry {\n\t\t\t\tconst result = await fn(...event.data.options);\n\t\t\t\tevent.source?.postMessage({ key: event.data.caller, result });\n\t\t\t} catch (error) {\n\t\t\t\tevent.source?.postMessage({ key: event.data.caller, error: (error as Error).message });\n\t\t\t}\n\t\t}\n\t}\n}\n","import { IConfig } from '../interfaces/IConfig';\nimport { IProvider } from '../interfaces/IProvider';\nimport { fetchListener } from './interceptor';\nimport { messageListener } from './postMesage';\nimport { getState } from './state';\nimport { log } from './utils';\n\nconst config = JSON.parse(decodeURIComponent(new URLSearchParams(location.search).get('config') || '{}')) as IConfig;\nconst debug = new URLSearchParams(location.search).get('debug') === '1';\n\nexport async function initAuthWorker(providers: Record<string, IProvider>): Promise<() => void> {\n\tconst state = await getState();\n\tstate.config = {\n\t\tconfig,\n\t\tproviders,\n\t\tdebug,\n\t};\n\n\tconst scope = globalThis as unknown as ServiceWorkerGlobalScope;\n\n\tstate.providers = providers;\n\n\tlog('init', state.config);\n\n\tscope.addEventListener('fetch', fetchListener);\n\tscope.addEventListener('message', messageListener);\n\n\treturn () => {\n\t\tscope.removeEventListener('fetch', fetchListener);\n\t\tscope.removeEventListener('message', messageListener);\n\t};\n}\n","export * from './shared/presets';\n","import { IProvider } from '../interfaces/IProvider';\nimport { GrantFlow } from './enums';\n\nexport const google: IProvider = {\n\tloginUrl: 'https://accounts.google.com/o/oauth2/v2/auth',\n\tgrantType: GrantFlow.Token,\n\taccessTokenName: 'access_token',\n\tuserInfoUrl: 'https://www.googleapis.com/oauth2/v3/userinfo',\n\tuserInfoTokenName: 'id_token',\n\tuserInfoParser(data: Record<string, unknown>) {\n\t\treturn {\n\t\t\tid: data.sub,\n\t\t\tname: data.name,\n\t\t\temail: data.email,\n\t\t\tpicture: data.picture,\n\t\t};\n\t},\n};\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\n// @ts-ignore\nimport { initAuthWorker } from 'auth-worker/worker';\nimport { google } from 'auth-worker/providers';\n\naddEventListener('install', () => {\n\t// @ts-ignore\n\tskipWaiting();\n});\n\naddEventListener('activate', (event) => {\n\t// @ts-ignore\n\tevent.waitUntil(clients.claim());\n});\n\ninitAuthWorker({ google });\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,UAAA,iBAAA,CAAA;AAAA,eAAA,gBAAA;QAAA,gBAAA,MAAAA;MAAA,CAAA;AAAA,aAAA,UAAA,aAAA,cAAA;ACkBO,eAAS,OAAO,MAA4B;AAClD,iBAAS,EAAE;UACV,CAACC,WAAU;AApBb,gBAAA;AAqBG,iBAAI,KAAAA,OAAM,WAAN,OAAA,SAAA,GAAc,OAAO;AACxB,sBAAQ,IAAI,iBAAiB,GAAG,IAAI;YACrC;UACD;UACA,MAAM;QACP;MACD;ACRA,UAAI,QAAuB;AAE3B,qBAAsB,WAAW;AAChC,YAAI,CAAC,OAAO;AACX,gBAAM,QAAQ,MAAM,OAAO,MAAM,OAAO;AACxC,kBAAQ,QAAU,MAAM,MAAM,KAAK,IAAgB,EAAE,WAAW,CAAC,EAAE;AACnE,cAAI,YAAY,KAAK;QACtB;AACA,eAAO;MACR;AAEA,qBAAsB,YAAY;AACjC,cAAM,QAAQ,MAAM,OAAO,KAAK,IAAI;AACpC,YAAI,aAAa,KAAK;AACtB,cAAM,MAAM,IAAI,SAAS,IAAI,SAAS,KAAK,UAAU,KAAK,CAAC,CAAC;MAC7D;AAEO,UAAM,oBAAoB,YAAgC;AApCjE,YAAA,IAAA,IAAA,IAAA;AAqCC,cAAMA,SAAQ,MAAM,SAAS;AAC7B,YAAI,GAAC,KAAAA,OAAM,YAAN,OAAA,SAAA,GAAe,WAAU;AAC7B,gBAAM,IAAI,MAAM,mBAAmB;QACpC;AACA,cAAM,kBAAiB,MAAA,KAAAA,OAAM,WAAN,OAAA,SAAA,GAAc,cAAd,OAAA,SAAA,IAA0B,KAAAA,OAAM,YAAN,OAAA,SAAA,GAAe;AAChE,YAAI,CAAC,gBAAgB;AACpB,gBAAM,IAAI,MAAM,0BAA0B;QAC3C;AACA,eAAO;MACR;AAEO,UAAM,qBAAqB,YAAkC;AAhDpE,YAAA,IAAA,IAAA,IAAA;AAiDC,cAAMA,SAAQ,MAAM,SAAS;AAC7B,YAAI,GAAC,KAAAA,OAAM,YAAN,OAAA,SAAA,GAAe,WAAU;AAC7B,gBAAM,IAAI,MAAM,mBAAmB;QACpC;AACA,cAAM,mBAAkB,MAAA,KAAAA,OAAM,WAAN,OAAA,SAAA,GAAc,WAAd,OAAA,SAAA,IAAuB,KAAAA,OAAM,YAAN,OAAA,SAAA,GAAe;AAC9D,YAAI,CAAC,iBAAiB;AACrB,gBAAM,IAAI,MAAM,2BAA2B;QAC5C;AACA,eAAO;MACR;AC1DO,eAAS,YAAY;AAC3B,YAAI,YAAY,cAAc,gBAAgB,WAAW,QAAQ;AAChE,iBAAO,WAAW,OAAO,WAAW;QACrC;AACA,eAAO,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,CAAC;MAC1C;ACFA,qBAAsB,eAAe;AACpC,cAAMA,SAAQ,MAAM,SAAS;AAC7B,YAAIA,OAAM,SAAS,MAAM;AACxBA,iBAAM,OAAO,UAAU;AACvB,oBAAU;QACX;AACA,eAAOA,OAAM;MACd;AAEA,qBAAsB,eAAe,OAAe;AACnD,cAAMA,SAAQ,MAAM,SAAS;AAC7B,eAAOA,OAAM,SAAS;MACvB;ACVA,eAAS,iBAAiB,MAAsC,SAAS,KAAe;AACvF,eAAO,IAAI,SAAS,KAAK,UAAU,IAAI,GAAG;UACzC,SAAS,EAAE,gBAAgB,mBAAmB;UAC9C;QACD,CAAC;MACF;AAEA,qBAAsB,eAA8B;AAZpD,YAAA;AAaC,cAAMA,SAAQ,MAAM,SAAS;AAC7B,cAAM,iBAAiB,MAAM,kBAAkB;AAC/C,cAAM,kBAAkB,MAAM,mBAAmB;AACjD,YAAI,CAAC,kBAAkB,EAAC,kBAAA,OAAA,SAAA,eAAgB,aAAY,GAAC,KAAAA,OAAM,YAAN,OAAA,SAAA,GAAe,eAAc;AACjF,gBAAM,IAAI,MAAM,6BAA6B;QAC9C;AAEA,cAAM,OAAO,MAAM,MAAM,eAAe,UAAU;UACjD,QAAQ;UACR,SAAS;YACR,gBAAgB;UACjB;UACA,MAAM,IAAI,gBAAgB;YACzB,WAAW,gBAAgB;YAC3B,YAAY;YACZ,cAAcA,OAAM,QAAQ;UAC7B,CAAC;QACF,CAAC;AAED,YAAI,KAAK,WAAW,KAAK;AACxB,gBAAM,IAAI,MAAM,yBAAyB;QAC1C;AAEA,cAAM,WAAW,MAAM,KAAK,KAAK;AAEjCA,eAAM,UAAU;UACf,UAAUA,OAAM,QAAQ;UACxB,aAAa,SAAS;UACtB,WAAW,SAAS;UACpB,cAAc,SAAS;UACvB,WAAW,KAAK,IAAI,IAAI,SAAS,aAAa;QAC/C;AAEA,YAAI,eAAe,mBAAmB;AACrCA,iBAAM,QAAQ,WAAW,SAAS,eAAe;QAClD;AACA,kBAAU;MACX;AAEA,qBAAsB,qBAAqB,SAAqC;AAC/E,cAAMA,SAAQ,MAAM,SAAS;AAC7B,YAAI,CAACA,OAAM,SAAS;AACnB,iBAAO,iBAAiB,EAAE,OAAA,EAA8B,GAAG,GAAG;QAC/D,WAAWA,OAAM,QAAQ,YAAY,KAAK,IAAI,GAAG;AAChD,cAAI;AACH,kBAAM,aAAa;UACpB,QAAA;AACC,mBAAO,iBAAiB,EAAE,OAAA,EAA8B,GAAG,GAAG;UAC/D;QACD;AAEA,cAAM,iBAAiB,IAAI,QAAQ,SAAS;UAC3C,SAAS;YACR,GAAG,QAAQ;YACX,eAAe,GAAGA,OAAM,QAAQ,aAAaA,OAAM,QAAQ;YAC3D,gBAAgB;YAChB,cAAc;UACf;QACD,CAAC;AACD,cAAM,WAAW,MAAM,MAAM,cAAc;AAC3C,YAAI,SAAS,WAAW,KAAK;AAC5B,cAAI;AACH,kBAAM,aAAa;UACpB,QAAA;AACC,mBAAO,iBAAiB,EAAE,OAAA,EAA8B,GAAG,GAAG;UAC/D;QACD;AACA,eAAO;MACR;AAEA,qBAAsB,cAAc,OAAmB;AACtD,YAAI,MAAM,QAAQ,WAAW,OAAO;AACnC,gBAAM,OAAO,MAAM,QAAQ,QAAQ,IAAI,cAAc;AACrD,cAAI,CAAC,QAAQ,CAAE,MAAM,eAAe,IAAI,GAAI;AAC3C,mBAAO,MAAM,YAAY,iBAAiB,EAAE,OAAA,EAA6B,GAAG,GAAG,CAAC;UACjF;QACD;AAEA,YAAI,MAAM,QAAQ,QAAQ,IAAI,YAAY,GAAG;AAC5C,cAAI,SAAS,MAAM,QAAQ,QAAQ,MAAM,QAAQ,KAAK;YACrD,MAAM,QAAQ,MAAM,QAAQ,QAAQ,IAAI,cAAc,CAAC;YACvD,MAAM,QAAQ,MAAM,QAAQ,QAAQ,IAAI,YAAY,CAAC;UACtD,CAAC;AACD,iBAAO,MAAM,YAAY,qBAAqB,MAAM,OAAO,CAAC;QAC7D;MACD;AC3FA,eAASC,EAAsBC,IAAAA;AAC3BC,aAAKD,UAAUA;MAAAA;AAGnBD,QAAsBG,YAAY,IAAIC,MAAAA,GACtCJ,EAAsBG,UAAUE,OAAO;AA6BvC,UAAA,IAAkC,eAAA,OAAXC,UACnBA,OAAOC,QACPD,OAAOC,KAAKC,KAAKF,MAAAA,KA7BrB,SAAkBG,IAAAA;AACd,YAAIC,KAAMC,OAAOF,EAAAA,EAAOG,QAAQ,OAAO,EAAA;AACvC,YAAIF,GAAIG,SAAS,KAAK;AAClB,gBAAM,IAAIb,EACN,mEAAA;AAGR,iBAEgBc,IAAIC,IAAZC,IAAK,GAAeC,IAAM,GAAGC,IAAS,IAEzCH,KAASL,GAAIS,OAAOF,GAAAA,GAAAA,CAEpBF,OACCD,KAAKE,IAAK,IAAS,KAALF,KAAUC,KAASA,IAG/BC,MAAO,KACVE,KAAUP,OAAOS,aAAa,MAAON,OAAAA,KAAaE,IAAM,EAAA,IACzD;AAGAD,eA/BI,oEA+BWM,QAAQN,EAAAA;AAE3B,eAAOG;MAAAA;ACxBI,eAAA,EAASR,IAAAA;AACpB,YAAIQ,KAASR,GAAIE,QAAQ,MAAM,GAAA,EAAKA,QAAQ,MAAM,GAAA;AAClD,gBAAQM,GAAOL,SAAS,GAAA;UACpB,KAAK;AACD;UACJ,KAAK;AACDK,kBAAU;AACV;UACJ,KAAK;AACDA,kBAAU;AACV;UACJ;AACI,kBAAM;QAAA;AAGd,YAAA;AACI,iBA5BR,SAA0BR,IAAAA;AACtB,mBAAOY,mBACHf,EAAKG,EAAAA,EAAKE,QAAQ,QAAQ,SAASW,IAAGC,IAAAA;AAClC,kBAAIC,KAAOD,GAAEE,WAAW,CAAA,EAAGC,SAAS,EAAA,EAAIC,YAAAA;AAIxC,qBAHIH,GAAKZ,SAAS,MACdY,KAAO,MAAMA,KAEV,MAAMA;YAAAA,CAAAA,CAAAA;UAAAA,EAqBOP,EAAAA;QAAAA,SACnBW,IADmBX;AAExB,iBAAOX,EAAKW,EAAAA;QAAAA;MAAAA;AC5Bb,eAASY,EAAkB7B,IAAAA;AAC9BC,aAAKD,UAAUA;MAAAA;AAMJ,eAAA,EAAS8B,IAAOC,IAAAA;AAC3B,YAAqB,YAAA,OAAVD;AACP,gBAAM,IAAID,EAAkB,yBAAA;AAIhC,YAAIG,KAAAA,UADJD,KAAUA,MAAW,CAAA,GACHE,SAAkB,IAAI;AACxC,YAAA;AACI,iBAAOC,KAAKC,MAAMC,EAAkBN,GAAMO,MAAM,GAAA,EAAKL,GAAAA,CAAAA;QAAAA,SAChDM,IADgDN;AAErD,gBAAM,IAAIH,EAAkB,8BAA8BS,GAAEtC,OAAAA;QAAAA;MAAAA;AAbpE6B,QAAkB3B,YAAY,IAAIC,MAAAA,GAClC0B,EAAkB3B,UAAUE,OAAO;AAAA,UAAA,yBAAA;ACJnC,qBAAsB,cAAc,QAAgB,UAAkB,YAAoB;AAL1F,YAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA;AAMC,cAAMN,SAAQ,MAAM,SAAS;AAC7B,cAAM,eAAe,IAAI,gBAAgB,MAAM;AAE/C,YAAI,CAACA,OAAM,QAAQ;AAClB,gBAAM,IAAI,MAAM,iBAAiB;QAClC;AAEA,cAAM,kBAAiB,KAAAA,OAAM,OAAO,cAAb,OAAA,SAAA,GAAyB;AAChD,cAAM,mBAAkB,KAAAA,OAAM,OAAO,WAAb,OAAA,SAAA,GAAsB;AAE9C,YAAI,CAAC,gBAAgB;AACpB,gBAAM,IAAI,MAAM,0BAA0B;QAC3C;AAEA,cAAM,aAAa,aAAa,KAAI,KAAA,eAAe,eAAf,OAAA,KAA6B,OAAO;AACxE,YAAI,eAAe,YAAY;AAC9B,gBAAM,IAAI,MAAM,eAAe;QAChC;AAEA,YAAI,eAAe,cAAA,GAA+B;AACjD,gBAAM,YAAY,UAAS,KAAA,aAAa,KAAI,KAAA,eAAe,kBAAf,OAAA,KAAgC,YAAY,MAA7D,OAAA,KAAkE,IAAI,EAAE,KAAK;AACxG,gBAAM,cAAc,aAAa,KAAI,KAAA,eAAe,oBAAf,OAAA,KAAkC,cAAc;AACrF,cAAI,CAAC,aAAa;AACjB,kBAAM,IAAI,MAAM,uBAAuB;UACxC;AACAA,iBAAM,UAAU;YACf;YACA;YACA,UAAU,eAAe,qBACtB,KAAA,aAAa,IAAI,eAAe,iBAAiB,MAAjD,OAAA,KAAsD,SACtD;YACH,YAAW,KAAA,aAAa,KAAI,KAAA,eAAe,kBAAf,OAAA,KAAgC,YAAY,MAA7D,OAAA,KAAkE;YAC7E,WAAW,KAAK,IAAI,IAAI,YAAY;UACrC;AACA,cAAI,SAASA,MAAK;QACnB;AAEA,YAAI,eAAe,cAAA,GAA2C;AAC7D,gBAAM,aAAa,aAAa,KAAI,KAAA,eAAe,2BAAf,OAAA,KAAyC,MAAM;AACnF,cAAI,CAAC,YAAY;AAChB,kBAAM,IAAI,MAAM,sBAAsB;UACvC;AACA,gBAAM,MAAM,MAAM,MAAM,eAAe,UAAU;YAChD,QAAQ;YACR,SAAS;cACR,gBAAgB;YACjB;YACA,MAAM,IAAI,gBAAgB;cACzB,WAAW,gBAAgB;cAC3B,YAAY;cACZ,MAAM;YACP,CAAC;UACF,CAAC;AAED,cAAI,IAAI,WAAW,KAAK;AACvB,kBAAM,IAAI,MAAM,qBAAqB;UACtC;AAEA,gBAAM,WAAW,MAAM,IAAI,KAAK;AAEhC,gBAAM,YAAY,UAAS,KAAA,eAAe,kBAAf,OAAA,KAAgC,OAAO;AAClE,gBAAM,cAAc,UAAS,KAAA,eAAe,oBAAf,OAAA,KAAkC;AAE/D,cAAI,CAAC,aAAa;AACjB,kBAAM,IAAI,MAAM,uBAAuB;UACxC;AAEAA,iBAAM,UAAU;YACf;YACA;YACA,YAAW,KAAA,UAAS,KAAA,eAAe,kBAAf,OAAA,KAAgC,kBAAzC,OAAA,KAA0D;YACrE,cAAc,UAAS,KAAA,eAAe,qBAAf,OAAA,KAAmC;YAC1D,UAAU,UAAS,KAAA,eAAe,sBAAf,OAAA,KAAoC;YACvD,WAAW,KAAK,IAAI,IAAI,YAAY;UACrC;AACA,cAAI,SAASA,MAAK;QACnB;AAEA,kBAAU;AACV,eAAO,YAAY;MACpB;AAEA,qBAAsB,cAAc;AAxFpC,YAAA,IAAA,IAAA,IAAA;AAyFC,cAAMA,SAAQ,MAAM,SAAS;AAC7B,YAAI,CAACA,OAAM,SAAS;AACnB,cAAI,SAASA,MAAK;AAClB,gBAAM,IAAI,MAAM,kBAAkB;QACnC;AAEA,cAAM,kBAAiB,MAAA,KAAAA,OAAM,WAAN,OAAA,SAAA,GAAc,cAAd,OAAA,SAAA,GAA0BA,OAAM,QAAQ;AAC/D,YAAIA,OAAM,QAAQ,UAAU;AAC3B,gBAAM,UAAmC,uBAAUA,OAAM,QAAQ,QAAQ;AACzE,mBAAO,KAAA,kBAAA,OAAA,SAAA,eAAgB,mBAAhB,OAAA,SAAA,GAAA,KAAA,gBAAiC,OAAA,MAAY;QACrD,WAAW,kBAAA,OAAA,SAAA,eAAgB,aAAa;AACvC,gBAAM,OAAO,MAAM,MAAM,eAAe,aAAa;YACpD,SAAS;cACR,eAAe,GAAGA,OAAM,QAAQ,aAAaA,OAAM,QAAQ;YAC5D;UACD,CAAC;AACD,cAAI,KAAK,WAAW,KAAK;AACxB,kBAAM,IAAI,MAAM,yBAAyB;UAC1C;AACA,gBAAM,WAAW,MAAM,KAAK,KAAK;AACjC,mBAAO,KAAA,kBAAA,OAAA,SAAA,eAAgB,mBAAhB,OAAA,SAAA,GAAA,KAAA,gBAAiC,QAAA,MAAa;QACtD;AAEA,cAAM,IAAI,MAAM,yBAAyB;MAC1C;AAEA,qBAAsB,gBAAgB;AACrC,cAAMA,SAAQ,MAAM,SAAS;AAC7BA,eAAM,UAAU;AAChB,kBAAU;MACX;ACnHA,UAAM,aAAa;QAClB;QACA;QACA;QACA;MACD;AAEA,qBAAsB,gBAAgB,OAA+B;AAXrE,YAAA,IAAA;AAYC,YAAI,WAAW,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM;AACjD,YAAI,MAAM,KAAK,SAAS,QAAQ;AAC/B,cAAI,MAAM,KAAK,UAAU,YAAY;AAEpC,kBAAM,KAAK,WAAW,MAAM,KAAK;AACjC,gBAAI;AACH,oBAAM,SAAS,MAAM,GAAG,GAAG,MAAM,KAAK,OAAO;AAC7C,eAAA,KAAA,MAAM,WAAN,OAAA,SAAA,GAAc,YAAY,EAAE,KAAK,MAAM,KAAK,QAAQ,OAAO,CAAA;YAC5D,SAAS,OAAT;AACC,eAAA,KAAA,MAAM,WAAN,OAAA,SAAA,GAAc,YAAY,EAAE,KAAK,MAAM,KAAK,QAAQ,OAAQ,MAAgB,QAAQ,CAAA;YACrF;UACD;QACD;MACD;AClBA,UAAM,SAAS,KAAK,MAAM,mBAAmB,IAAI,gBAAgB,SAAS,MAAM,EAAE,IAAI,QAAQ,KAAK,IAAI,CAAC;AACxG,UAAM,QAAQ,IAAI,gBAAgB,SAAS,MAAM,EAAE,IAAI,OAAO,MAAM;AAEpE,qBAAsBD,gBAAe,WAA2D;AAC/F,cAAMC,SAAQ,MAAM,SAAS;AAC7BA,eAAM,SAAS;UACd;UACA;UACA;QACD;AAEA,cAAM,QAAQ;AAEdA,eAAM,YAAY;AAElB,YAAI,QAAQA,OAAM,MAAM;AAExB,cAAM,iBAAiB,SAAS,aAAa;AAC7C,cAAM,iBAAiB,WAAW,eAAe;AAEjD,eAAO,MAAM;AACZ,gBAAM,oBAAoB,SAAS,aAAa;AAChD,gBAAM,oBAAoB,WAAW,eAAe;QACrD;MACD;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA,UAAA,oBAAA,CAAA;AAAA,eAAA,mBAAA;QAAA,QAAA,MAAAyC;MAAA,CAAA;AAAA,aAAA,UAAA,aAAA,iBAAA;ACGO,UAAMA,UAAoB;QAChC,UAAU;QACV,WAAA;QACA,iBAAiB;QACjB,aAAa;QACb,mBAAmB;QACnB,eAAe,MAA+B;AAC7C,iBAAO;YACN,IAAI,KAAK;YACT,MAAM,KAAK;YACX,OAAO,KAAK;YACZ,SAAS,KAAK;UACf;QACD;MACD;;;;;ACfA,sBAA+B;AAC/B,yBAAuB;AAEvB,mBAAiB,WAAW,MAAM;AAEjC,gBAAY;AAAA,EACb,CAAC;AAED,mBAAiB,YAAY,CAAC,UAAU;AAEvC,UAAM,UAAU,QAAQ,MAAM,CAAC;AAAA,EAChC,CAAC;AAED,oCAAe,EAAE,gCAAO,CAAC;","names":["initAuthWorker","state","InvalidCharacterError","message","this","prototype","Error","name","window","atob","bind","input","str","String","replace","length","bs","buffer","bc","idx","output","charAt","fromCharCode","indexOf","decodeURIComponent","m","p","code","charCodeAt","toString","toUpperCase","err","InvalidTokenError","token","options","pos","header","JSON","parse","base64_url_decode","split","e","google"]}